package io.github.mikeddavydov.jpwise;

import io.github.mikeddavydov.jpwise.core.CombinationTable;
import io.github.mikeddavydov.jpwise.core.CompatibilityPredicate;
import io.github.mikeddavydov.jpwise.core.CyclingPartition;
import io.github.mikeddavydov.jpwise.core.SimpleValue;
import io.github.mikeddavydov.jpwise.core.TestParameter;
import java.util.Arrays;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

/**
 * Demonstrates how to use JPWise with TestNG's data provider feature. This allows running the same
 * test with different parameter combinations generated by the pairwise algorithm.
 */
public class JPWiseQuickDemoTest {
  private static final Logger log = LoggerFactory.getLogger(JPWiseQuickDemoTest.class);
  private static final CombinationTable DEMO_COMBINATIONS = generateJPWiseData();

  private static CombinationTable generateJPWiseData() {
    // Define a rule: "Safari" browser is only compatible with "macOS"
    List<CompatibilityPredicate> browserRules =
        Arrays.asList(
            (ep1, ep2) -> {
              // Note: README uses ep1.getName(), assuming ep is an EquivalencePartition
              // If ep1, ep2 are TestParameterValue, then it would be ep1.getParameter().getName()
              // or ep1.getPartition().getName() depending on what CompatibilityPredicate receives.
              // For now, assuming .getName() directly on the object passed is what the README
              // implied.
              // The actual CompatibilityPredicate takes (EquivalencePartition,
              // EquivalencePartition)
              // so ep1.getName() should be correct if ep1 is the partition instance.
              // However, the rule logic is usually on values, not partition names.
              // The README example's rule: (ep1, ep2) -> { if (ep1.getName().equals("Safari") ... }
              // This implies ep1 is the EquivalencePartition instance itself.
              // Let's stick to the README's direct logic.
              if (ep1.getName().equals("Safari") && !ep2.getName().equals("macOS")) {
                return false; // Safari is incompatible with non-macOS
              }
              return true; // Otherwise compatible
            });

    // Match README: Parameter "Browser" with CyclingPartition and SimpleValue for Safari
    // Add rules to the "Browser" parameter as it's where "Safari" is defined.
    TestParameter browser =
        TestParameter.of(
            "Browser",
            Arrays.asList(
                CyclingPartition.of("Chrome", Arrays.asList("latest", "previous")),
                SimpleValue.of("Safari")),
            browserRules); // Apply rules to the parameter containing "Safari"

    TestParameter os = TestParameter.of("OS", SimpleValue.of("macOS"), SimpleValue.of("Windows"));

    return JPWise.builder().parameter(browser).parameter(os).generatePairwise();
  }

  @DataProvider(name = "jpwiseTestData") // Matches README
  public Object[][] getTestDataFromJPWise() {
    return DEMO_COMBINATIONS.asDataProvider();
  }

  @Test(dataProvider = "jpwiseTestData") // Matches README
  public void testFeatureWithVariedConfigs(String description, String browser, String os) {
    // description provides a summary (e.g., "Browser=Chrome(latest), OS=Windows")
    log.info("Testing: {}", description); // README uses System.out.printf

    // Adding assertions based on the rule for completeness, though not in README's test method
    if ("Safari".equals(browser)) {
      assert "macOS".equals(os) : "Safari should only be paired with macOS";
    }
    // Your test implementation here (as per README)
  }
}
